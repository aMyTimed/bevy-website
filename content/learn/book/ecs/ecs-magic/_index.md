+++
title = "Understanding the magic"
weight = 8
template = "book-section.html"
page_template = "book-section.html"
insert_anchor_links = "right"
+++

By this point, it's common for new Bevy users to have a few questions about how the high-level tools you've been introduced to actually perform their feats of cunning ergonomics.
You may have wondered:

1. How does Bevy convert a function to a system when we call [`App::add_system`]?
2. How does the app know which data a given system needs access to?
3. How are systems called by the main game loop?
4. How does each system actually *get* its data?

**This page is *completely* optional; if you just want to make cool things, embrace the magic and skip this page!**

Now, let's pull back the curtain, and take a look at the inner mechanisms and low-level APIs of [`bevy_ecs`] to answer these questions, one at a time.

### Adding functions as systems

Conceptually, this is straightforward: we pass in our functions as [first-class objects](https://en.wikipedia.org/wiki/First-class_function), examine their properties, store them in our [`Schedule`] and then call them repeatedly when our [`App`]'s [`runner`] requests them.

But of course, that's hand-waving: how does it *really* work?
We can pick up the trail by examining [`App::add_system`]: we find that it's generic over any type that implements the [`IntoSystemDescriptor`] trait.

This trait defines a conversion between the underlying function, and the [`SystemDescriptor`] representation, which stores scheduler-relevant information, as well as the system itself in [`BoxedSystem`] form, which is a [boxed](https://doc.rust-lang.org/std/boxed/index.html) [`System`] trait object.

Once our system is neatly boxed up, we can examine the methods of [`System`], which provide an interface to access all of the interesting information about the function that we've transformed into a system.
The most important method here is [`System::run`], which allows callers (like a [`Schedule`]) to correctly run the system.

Functions are converted into systems using a [blanket implementation](https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods) of the [`IntoSystem`] trait, allowing us to [extend](http://xion.io/post/code/rust-extension-traits.html) existing functions whose signature meets our criteria.
By calling the [`IntoSystem::system()`] method when we attempt to run our systems, our function starts its path to becoming a well-behaved, fully-initialized system.

The [blanket implementation in question](https://github.com/bevyengine/bevy/blob/6615b7bf6439c9bcaf59982b2713e1c1564bf0f5/crates/bevy_ecs/src/system/function_system.rs#L422) covers `impl<In, Out, Param, Marker, F> IntoSystem<In, Out, (IsFunctionSystem, Param, Marker)> for F` where `F` implements [`IntoSystem`].
Here, at the bottom of our stack of abstractions, we find the heart of the magic: a collection of implementations (generated by macro due to the lack of [variadic generics](https://github.com/rust-lang/rfcs/issues/376)) that describe how to convert functions with arguments that implement [`SystemParam`], along with a [`System::run_unsafe`] method!

[`Schedule`]: https://docs.rs/bevy/latest/bevy/ecs/schedule/struct.Schedule.html
[`App`]: https://docs.rs/bevy/latest/bevy/app/struct.App.html
[`runner`]: https://docs.rs/bevy/latest/bevy/app/struct.App.html#structfield.runner
[`App::add_system`]: https://docs.rs/bevy/latest/bevy/app/struct.App.html#method.add_system
[`IntoSystemDescriptor`]: https://docs.rs/bevy/latest/bevy/ecs/schedule/trait.IntoSystemDescriptor.html
[`SystemDescriptor`]: https://docs.rs/bevy/latest/bevy/ecs/schedule/enum.SystemDescriptor.html
[`BoxedSystem`]: https://docs.rs/bevy/latest/bevy/ecs/system/type.BoxedSystem.html
[`System`]: https://docs.rs/bevy/latest/bevy/ecs/system/trait.System.html
[`System::run`]: https://docs.rs/bevy/latest/bevy/ecs/system/trait.System.html#method.run
[`IntoSystem`]: https://docs.rs/bevy/latest/bevy/ecs/system/trait.IntoSystem.html
[`IntoSystem::system()`]: https://docs.rs/bevy/latest/bevy/ecs/system/trait.IntoSystem.html#tymethod.system
[`SystemParam`]: https://docs.rs/bevy/latest/bevy/ecs/system/trait.SystemParam.html
[`System::run_unsafe`]: https://docs.rs/bevy/latest/bevy/ecs/system/trait.System.html#tymethod.run_unsafe

### Smart data access

So, how do systems know which data they need access to in order to enable multiple systems to safely and automatically run in parallel?
In the [`System`] trait, we can see two relevant methods: [`component_access`] and [`archetype_component_acesss`].

The [`Access`] struct returned by those methods keeps track of the read and write accesses of a system: either on a [`ComponentId`] or [`ArchetypeComponentId`].
These store the types of each resource and component as a cheap, safe identifier ultimately created out of a [`TypeId`] during type registration, which automatically occurs the first time a component or resource type is used.
This, fundamentally, is why we're limited to one of each type of component per entity: we use this type information to dispatch data.

Through the use of [`Access::is_compatible`], we can determine if two systems have compatible data access patterns, and block them from running in parallel if they do not.
This can be done in a smart, cached fashion and is combined with explicit system ordering constraints to create a list of systems and their constraints.
Systems are run in a greedy fashion, scheduling the next available unconstrained system as soon as a thread is free to accept work.

But of course, every answer leads to more questions! How does Bevy know which access a system will need based on the arguments of the underlying function?
To get the answer to this question, we must turn to the [`SystemParam`] trait once more.

You'll recall that every parameter in our system functions must implement [`SystemParam`], and this information is somehow transformed into a fully-fledged [`System`]-implementing object, which has the access information we're curious about.

The key is in the associated type [`Fetch`] on [`SystemParam`].
This type must implement the [`SystemParamFetch`] trait,
and stores the information we need inside its [`SystemMeta`] field.
Inside *that* is a private field: `archetype_component_access: Access<ArchetypeComponentId>`, allowing the implementer to define the component data (at an [archetype level of granularity](https://github.com/bevyengine/bevy/pull/1525)) that are accessed by this system parameter!

The accesses of a system are defined as the [union](https://en.wikipedia.org/wiki/Union_(set_theory)) of the accesses of all of its system parameters, allowing us to convert from the access needed for each parameter into the final form needed by the scheduler, concluding our detective work for the day.

[`component_access`]: https://docs.rs/bevy/latest/bevy/ecs/prelude/trait.System.html#tymethod.component_access
[`archetype_component_access`]: https://docs.rs/bevy/latest/bevy/ecs/prelude/trait.System.html#tymethod.archetype_component_access
[`Access`]: https://docs.rs/bevy/latest/bevy/ecs/query/struct.Access.html
[`ComponentId`]: https://docs.rs/bevy/latest/bevy/ecs/component/struct.ComponentId.html
[`ArchetypeComponentId`]: https://docs.rs/bevy/latest/bevy/ecs/archetype/struct.ArchetypeComponentId.html
[`TypeId`]: https://doc.rust-lang.org/std/any/struct.TypeId.html
[`Access::is_compatible`]: https://docs.rs/bevy/latest/bevy/ecs/query/struct.Access.html#method.is_compatible
[`Fetch`]: https://docs.rs/bevy/latest/bevy/ecs/system/trait.SystemParam.html#associatedtype.Fetch
[`SystemMeta`]: https://docs.rs/bevy/latest/bevy/ecs/system/struct.SystemMeta.html

### Running systems

What happens when we call [`App::run`]?
Well, on the surface it's quite simple: our [`runner`] field of [`App`], which stores a function in the form of `Box<dyn Fn(App)>` is called, taking the configured app as its argument.

By default, this begins as a `Box::new(run_once)`, which is a trivial function that calls [`App::update`] a single time.
When this method is called, the [`World`]'s [`Schedule`] is initialized, then run as a [`Stage`].

[`Stage`] takes a mutable reference to the world, and its typical implementer [`SystemStage`] contains all of Bevy's scheduling and dispatch logic, allowing us to carefully dole out access to our data in safely parallelized fashion.

This simple "update the app once" runner logic can be easily customized and changed: both [by the end user](https://github.com/bevyengine/bevy/blob/main/examples/app/custom_loop.rs) and by our [`DefaultPlugins`] whose [`WinitPlugin`] changes the runner to [`winit_runner`], which  repeatedly updates the app and interfaces with the [`winit`] crate Bevy depends on to establish windowing and input handling before the system schedule is run.

[`App::run`]: https://docs.rs/bevy/latest/bevy/app/struct.App.html#method.run
[`App::update`]: https://docs.rs/bevy/latest/bevy/app/struct.App.html#method.update
[`Stage`]: https://docs.rs/bevy/latest/bevy/ecs/schedule/trait.Stage.html
[`SystemStage`]: https://docs.rs/bevy/latest/bevy/ecs/schedule/struct.SystemStage.html
[`DefaultPlugins`]: https://docs.rs/bevy/latest/bevy/struct.DefaultPlugins.html
[`WinitPlugin`]: https://docs.rs/bevy/latest/bevy/winit/struct.WinitPlugin.html
[`winit`]: https://docs.rs/winit/latest/winit/

### Data dispatch

There's one last piece of the puzzle: how do we actually pass references to that data from the [`World`] into our systems when the schedule is run?

For parallel systems, this logic is contained within [`FunctionSystem::run_unsafe`], which is a method of the [`System`] trait.
Ultimately, the data is fetched using the unsafe method [`SystemParamFetch::get_param`], which extracts the information specified in [`SystemMeta`] from the world directly.

The safety of this is fundamentally upheld by our **executor**, which runs our schedule according to a particular strategy.
Executors must update the list of archetypes that exist in the world each frame to ensure that system data access is safe and avoid false-positives by splitting our column-like component data storage into non-overlapping sets based on the collection of components that entities in our world actually have.
The default executor used in Bevy is [`ParallelExecutor`], which executes systems in parallel in a simple and non-deterministic first-come-first-serve fashion that respects system ordering.
Check out the source code (and the [section on system ordering](../../game-logic/system-ordering/_index.md)) for more details on how this is done.

[`FunctionSystem::run_unsafe`]: https://docs.rs/bevy/latest/bevy/ecs/system/struct.FunctionSystem.html#method.run_unsafe
[`SystemParamFetch::get_param`]: https://docs.rs/bevy/latest/bevy/ecs/system/trait.SystemParamFetch.html#tymethod.get_param
[`ParallelExecutor`]: https://docs.rs/bevy/latest/bevy/ecs/schedule/struct.ParallelExecutor.html
